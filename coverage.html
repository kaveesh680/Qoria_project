
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">abt-dashboard-api/docs/docs.go (0.0%)</option>
				
				<option value="file1">abt-dashboard-api/internal/application/cron/summary_table_refresh_job.go (0.0%)</option>
				
				<option value="file2">abt-dashboard-api/internal/application/database/connection.go (100.0%)</option>
				
				<option value="file3">abt-dashboard-api/internal/application/http/getCountryRevenue/decoder.go (0.0%)</option>
				
				<option value="file4">abt-dashboard-api/internal/application/http/getCountryRevenue/encoder.go (0.0%)</option>
				
				<option value="file5">abt-dashboard-api/internal/application/http/getCountryRevenue/handler.go (0.0%)</option>
				
				<option value="file6">abt-dashboard-api/internal/application/http/getMonthlySalesVolume/decoder.go (0.0%)</option>
				
				<option value="file7">abt-dashboard-api/internal/application/http/getMonthlySalesVolume/encoder.go (0.0%)</option>
				
				<option value="file8">abt-dashboard-api/internal/application/http/getMonthlySalesVolume/handler.go (0.0%)</option>
				
				<option value="file9">abt-dashboard-api/internal/application/http/getTopProducts/decoder.go (0.0%)</option>
				
				<option value="file10">abt-dashboard-api/internal/application/http/getTopProducts/encoder.go (0.0%)</option>
				
				<option value="file11">abt-dashboard-api/internal/application/http/getTopProducts/handler.go (0.0%)</option>
				
				<option value="file12">abt-dashboard-api/internal/application/http/getTopRegions/decoder.go (0.0%)</option>
				
				<option value="file13">abt-dashboard-api/internal/application/http/getTopRegions/encoder.go (0.0%)</option>
				
				<option value="file14">abt-dashboard-api/internal/application/http/getTopRegions/handler.go (0.0%)</option>
				
				<option value="file15">abt-dashboard-api/internal/application/http/ping/decoder.go (0.0%)</option>
				
				<option value="file16">abt-dashboard-api/internal/application/http/ping/encoder.go (100.0%)</option>
				
				<option value="file17">abt-dashboard-api/internal/application/http/ping/handler.go (50.0%)</option>
				
				<option value="file18">abt-dashboard-api/internal/application/http/server.go (0.0%)</option>
				
				<option value="file19">abt-dashboard-api/internal/domain/repository/transactions.go (82.1%)</option>
				
				<option value="file20">abt-dashboard-api/internal/domain/services/get_country_revenue.go (100.0%)</option>
				
				<option value="file21">abt-dashboard-api/internal/domain/services/get_top_regions.go (100.0%)</option>
				
				<option value="file22">abt-dashboard-api/internal/domain/services/monthly_sales.go (100.0%)</option>
				
				<option value="file23">abt-dashboard-api/internal/domain/services/top_products.go (100.0%)</option>
				
				<option value="file24">abt-dashboard-api/internal/init.go (0.0%)</option>
				
				<option value="file25">abt-dashboard-api/main.go (0.0%)</option>
				
				<option value="file26">abt-dashboard-api/pkg/database/database.go (0.0%)</option>
				
				<option value="file27">abt-dashboard-api/pkg/errors/error.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/ping": {
            "get": {
                "description": "Returns a simple ping response to verify that the server is running.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Utility"
                ],
                "summary": "Health Check",
                "responses": {
                    "200": {
                        "description": "ping",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.ApplicationError"
                        }
                    }
                }
            }
        },
        "/v1/metrics/country-revenue": {
            "get": {
                "description": "Returns a paginated list of countries with product revenue and transaction count, sorted by total revenue.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get country-level revenue data",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 50,
                        "description": "Number of records to return",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Number of records to skip",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.CountryRevenueResponse"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errors.DomainError"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errors.ApplicationError"
                        }
                    }
                }
            }
        },
        "/v1/metrics/monthly-sales": {
            "get": {
                "description": "Returns a list of months with their total item sales, sorted by highest sales volume.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get monthly sales volume",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 12,
                        "description": "Number of top months to return",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.MonthlySalesVolume"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errors.DomainError"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errors.ApplicationError"
                        }
                    }
                }
            }
        },
        "/v1/metrics/top-products": {
            "get": {
                "description": "Returns a list of top frequently purchased products with their total purchased count and current available stock.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get top frequently purchased products",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Number of top products to return",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.TopProduct"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errors.DomainError"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errors.ApplicationError"
                        }
                    }
                }
            }
        },
        "/v1/metrics/top-regions": {
            "get": {
                "description": "Returns a list of regions with the highest total revenue and items sold, sorted by revenue.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get top regions by revenue",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 30,
                        "description": "Number of top regions to return",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.RegionRevenue"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errors.DomainError"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errors.ApplicationError"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "entity.CountryRevenueResponse": {
            "type": "object",
            "properties": {
                "country": {
                    "type": "string"
                },
                "product_name": {
                    "type": "string"
                },
                "total_revenue": {
                    "type": "number"
                },
                "transaction_count": {
                    "type": "integer"
                }
            }
        },
        "entity.MonthlySalesVolume": {
            "type": "object",
            "properties": {
                "month": {
                    "type": "string"
                },
                "total_sales": {
                    "type": "integer"
                }
            }
        },
        "entity.RegionRevenue": {
            "type": "object",
            "properties": {
                "items_sold": {
                    "type": "integer"
                },
                "region": {
                    "type": "string"
                },
                "total_revenue": {
                    "type": "number"
                }
            }
        },
        "entity.TopProduct": {
            "type": "object",
            "properties": {
                "availableStock": {
                    "type": "integer"
                },
                "productName": {
                    "type": "string"
                },
                "product_id": {
                    "type": "string"
                },
                "purchaseCount": {
                    "type": "integer"
                }
            }
        },
        "errors.ApplicationError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "errors.DomainError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cron

import (
        "abt-dashboard-api/internal/domain/repository"
        "context"
        "database/sql"
        "log"

        "github.com/robfig/cron/v3"
)

const logPrefixCronJob = `abt-dashboard-api.internal.application.cron.summary_table_refresh_job`

func StartSummaryTableRefreshJob(db *sql.DB) *cron.Cron <span class="cov0" title="0">{

        if err := RunSummaryTableRefresh(db); err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [%s]: Initial summary refresh failed: %v", logPrefixCronJob, err)
        }</span>

        <span class="cov0" title="0">c := cron.New()

        _, err := c.AddFunc("0 0 * * *", func() </span><span class="cov0" title="0">{
                log.Printf("INFO [%s]: Running scheduled summary table refresh job...", logPrefixCronJob)

                if err := RunSummaryTableRefresh(db); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: Scheduled summary refresh failed: %v", logPrefixCronJob, err)
                        return
                }</span>

                <span class="cov0" title="0">log.Printf("INFO [%s]: Scheduled summary tables refreshed successfully.", logPrefixCronJob)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("FATAL [%s]: Error scheduling cron job: %v", logPrefixCronJob, err)
        }</span>

        <span class="cov0" title="0">c.Start()
        log.Printf("INFO [%s]: Cron job for summary table refresh started.", logPrefixCronJob)

        return c</span>
}

func RunSummaryTableRefresh(db *sql.DB) error <span class="cov0" title="0">{
        log.Printf("INFO [%s]: Running summary table refresh job...", logPrefixCronJob)

        repo := repository.NewTransactionRepository(db)
        ctx := context.Background()

        if err := repo.RefreshSummaryTables(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [%s]: Failed to refresh summary tables: %v", logPrefixCronJob, err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("INFO [%s]: Summary tables refreshed successfully.", logPrefixCronJob)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "abt-dashboard-api/pkg/database"
        "database/sql"
        "fmt"
        "log"
        "time"

        _ "github.com/go-sql-driver/mysql"
)

type DBConfig struct {
        Username          string
        Password          string
        Database          string
        Host              string
        Port              string
        ReadTimeout       string
        WriteTimeout      string
        ConnectionTimeout string
}

func NewDbConfig(
        userName string,
        password string,
        database string,
        host string,
        port string,
        readTimeout string,
        writeTimeout string,
        connectionTimeout string,
) *DBConfig <span class="cov8" title="1">{
        return &amp;DBConfig{
                Username:          userName,
                Password:          password,
                Database:          database,
                Host:              host,
                Port:              port,
                ReadTimeout:       readTimeout,
                WriteTimeout:      writeTimeout,
                ConnectionTimeout: connectionTimeout,
        }
}</span>

func (d *DBConfig) NewDatabaseConnection(connector database.SQLConnector) (*sql.DB, error) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true&amp;readTimeout=%s&amp;writeTimeout=%s&amp;timeout=%s",
                d.Username,
                d.Password,
                d.Host,
                d.Port,
                d.Database,
                d.ReadTimeout,
                d.WriteTimeout,
                d.ConnectionTimeout,
        )

        db, err := connector.Open("mysql", dsn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(0)
        db.SetConnMaxIdleTime(1 * time.Minute)
        db.SetConnMaxLifetime(10 * time.Minute)

        if err := connector.Ping(db); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">log.Println("Successfully connected to database")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package getCountryRevenue

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "net/http"
        "strconv"
)

func DecodeGetCountryRevenueRequest(_ context.Context, r *http.Request) (interface{}, error) <span class="cov0" title="0">{
        query := r.URL.Query()

        limit := 50
        offset := 0

        if l, err := strconv.Atoi(query.Get("limit")); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                limit = l
        }</span>

        <span class="cov0" title="0">if o, err := strconv.Atoi(query.Get("offset")); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                offset = o
        }</span>

        <span class="cov0" title="0">return entity.GetCountryRevenueRequest{
                Limit:  limit,
                Offset: offset,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package getCountryRevenue

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "encoding/json"
        "net/http"
)

func EncodeGetCountryRevenueResponse(_ context.Context, w http.ResponseWriter, response interface{}) error <span class="cov0" title="0">{
        r := response.(*[]entity.CountryRevenueResponse)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        return json.NewEncoder(w).Encode(r)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package getCountryRevenue

import (
        "abt-dashboard-api/internal/domain/entity"
        "abt-dashboard-api/internal/domain/repository"
        "abt-dashboard-api/internal/domain/services"
        "abt-dashboard-api/pkg/errors"
        "database/sql"
        "log"
        "net/http"
)

const prefixHttpHandler = "abt-dashboard-api.internal.application.http.getCountryRevenue.handler"

// GetCountryRevenueHandler godoc
// @Summary Get country-level revenue data
// @Description Returns a paginated list of countries with product revenue and transaction count, sorted by total revenue.
// @Tags Metrics
// @Accept  json
// @Produce  json
// @Param limit query int false "Number of records to return" default(50)
// @Param offset query int false "Number of records to skip" default(0)
// @Success 200 {array} entity.CountryRevenueResponse
// @Failure 400 {object} errors.DomainError "Invalid request parameters"
// @Failure 500 {object} errors.ApplicationError "Internal server error"
// @Router /v1/metrics/country-revenue [get]
func Handler(dbConn *sql.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                decodedReq, err := DecodeGetCountryRevenueRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: DecodeGetCountryRevenueRequest.Error : %v", prefixHttpHandler, err)
                        errors.EncodeError(w, errors.NewDomainError("Invalid request params", 10001))
                        return
                }</span>
                <span class="cov0" title="0">req := decodedReq.(entity.GetCountryRevenueRequest)

                getCountryRevenueService := services.NewGetCountryRevenueService(
                        repository.NewTransactionRepository(dbConn),
                )

                countryRevenues, err := getCountryRevenueService.GetCountryRevenue(ctx, req.Limit, req.Offset)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: getCountryRevenyeService.GetCountryRevenue.Error : %v", prefixHttpHandler, err)
                        domainErr := errors.NewDomainError("Oops, Something went wrong!", 12212)
                        errors.EncodeError(w, domainErr)
                        return
                }</span>

                <span class="cov0" title="0">if err := EncodeGetCountryRevenueResponse(ctx, w, countryRevenues); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: failed to encode country revenue response: %v", prefixHttpHandler, err)
                        appErr := errors.NewApplicationError("Oops, Something went wrong!", 1234234)
                        errors.EncodeError(w, appErr)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package getMonthlySalesVolume

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "net/http"
        "strconv"
)

func DecodeMonthlySalesRequest(_ context.Context, r *http.Request) (interface{}, error) <span class="cov0" title="0">{
        query := r.URL.Query()
        limit := 12 // default to 12 months

        if l, err := strconv.Atoi(query.Get("limit")); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                limit = l
        }</span>

        <span class="cov0" title="0">return entity.MonthlySalesRequest{Limit: limit}, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package getMonthlySalesVolume

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "encoding/json"
        "net/http"
)

func EncodeMonthlySalesResponse(_ context.Context, w http.ResponseWriter, response interface{}) error <span class="cov0" title="0">{
        r := response.(*[]entity.MonthlySalesVolume)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        return json.NewEncoder(w).Encode(r)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package getMonthlySalesVolume

import (
        "abt-dashboard-api/internal/domain/entity"
        "abt-dashboard-api/internal/domain/repository"
        "abt-dashboard-api/internal/domain/services"
        "abt-dashboard-api/pkg/errors"
        "database/sql"
        "log"
        "net/http"
)

const prefix = "abt-dashboard-api.internal.application.http.getMonthlySalesVolume.handler"

// GetMonthlySalesVolumeHandler godoc
// @Summary Get monthly sales volume
// @Description Returns a list of months with their total item sales, sorted by highest sales volume.
// @Tags Metrics
// @Accept  json
// @Produce  json
// @Param limit query int false "Number of top months to return" default(12)
// @Success 200 {array} entity.MonthlySalesVolume
// @Failure 400 {object} errors.DomainError "Invalid request parameters"
// @Failure 500 {object} errors.ApplicationError "Internal server error"
// @Router /v1/metrics/monthly-sales [get]
func Handler(db *sql.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                decodedReq, err := DecodeMonthlySalesRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: DecodeMonthlySalesRequest: %v", prefix, err)
                        errors.EncodeError(w, errors.NewDomainError("Invalid request params", 10002))
                        return
                }</span>
                <span class="cov0" title="0">req := decodedReq.(entity.MonthlySalesRequest)

                service := services.NewMonthlySalesService(repository.NewTransactionRepository(db))

                data, err := service.GetMonthlySalesVolume(ctx, req.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: GetMonthlySalesVolume: %v", prefix, err)
                        errors.EncodeError(w, errors.NewDomainError("Failed to fetch sales data", 12214))
                        return
                }</span>

                <span class="cov0" title="0">if err := EncodeMonthlySalesResponse(ctx, w, data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: Encode response: %v", prefix, err)
                        errors.EncodeError(w, errors.NewApplicationError("Failed to encode response", 1234236))
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package getTopProducts

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "net/http"
        "strconv"
)

func DecodeTopProductsRequest(_ context.Context, r *http.Request) (interface{}, error) <span class="cov0" title="0">{
        query := r.URL.Query()

        limit := 20 // default
        if l, err := strconv.Atoi(query.Get("limit")); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                limit = l
        }</span>

        <span class="cov0" title="0">return entity.TopProductsRequest{
                Limit: limit,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package getTopProducts

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "encoding/json"
        "net/http"
)

func encodeGetTopProductsResponse(_ context.Context, w http.ResponseWriter, response interface{}) error <span class="cov0" title="0">{
        r := response.(*[]entity.TopProduct)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        return json.NewEncoder(w).Encode(r)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package getTopProducts

import (
        "abt-dashboard-api/internal/domain/entity"
        "abt-dashboard-api/internal/domain/repository"
        "abt-dashboard-api/internal/domain/services"
        "abt-dashboard-api/pkg/errors"
        "database/sql"
        "log"
        "net/http"
)

const prefixHttpHandler = "abt-dashboard-api.internal.application.http.getTopProducts.handler"

// GetTopProductsHandler godoc
// @Summary Get top frequently purchased products
// @Description Returns a list of top frequently purchased products with their total purchased count and current available stock.
// @Tags Metrics
// @Accept  json
// @Produce  json
// @Param limit query int false "Number of top products to return" default(20)
// @Success 200 {array} entity.TopProduct
// @Failure 400 {object} errors.DomainError "Invalid request parameters"
// @Failure 500 {object} errors.ApplicationError "Internal server error"
// @Router /v1/metrics/top-products [get]
func Handler(dbConn *sql.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                decodedReq, err := DecodeTopProductsRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: DecodeTopProductsRequest.Error : %v", prefixHttpHandler, err)
                        errors.EncodeError(w, errors.NewDomainError("Invalid request params", 10002))
                        return
                }</span>
                <span class="cov0" title="0">req := decodedReq.(entity.TopProductsRequest)

                service := services.NewGetTopProductsService(
                        repository.NewTransactionRepository(dbConn),
                )

                products, err := service.GetTopProducts(ctx, req.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: GetTopProductsService.GetTopProducts.Error : %v", prefixHttpHandler, err)
                        errors.EncodeError(w, errors.NewDomainError("Failed to fetch top products", 12213))
                        return
                }</span>

                <span class="cov0" title="0">if err := encodeGetTopProductsResponse(ctx, w, products); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: failed to encode top products response: %v", prefixHttpHandler, err)
                        errors.EncodeError(w, errors.NewApplicationError("Failed to encode response", 1234235))
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package getTopRegions

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "net/http"
        "strconv"
)

func DecodeTopRegionsRequest(_ context.Context, r *http.Request) (interface{}, error) <span class="cov0" title="0">{
        query := r.URL.Query()

        limit := 30 // default
        if l, err := strconv.Atoi(query.Get("limit")); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                limit = l
        }</span>

        <span class="cov0" title="0">return entity.TopRegionsRequest{Limit: limit}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package getTopRegions

import (
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "encoding/json"
        "net/http"
)

func EncodeTopRegionsResponse(_ context.Context, w http.ResponseWriter, response interface{}) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        return json.NewEncoder(w).Encode(response.(*[]entity.RegionRevenue))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package getTopRegions

import (
        "abt-dashboard-api/internal/domain/entity"
        "abt-dashboard-api/internal/domain/repository"
        "abt-dashboard-api/internal/domain/services"
        "abt-dashboard-api/pkg/errors"
        "database/sql"
        "log"
        "net/http"
)

const logPrefix = "abt-dashboard-api.internal.application.http.getTopRegions.handler"

// GetTopRegionsHandler godoc
// @Summary Get top regions by revenue
// @Description Returns a list of regions with the highest total revenue and items sold, sorted by revenue.
// @Tags Metrics
// @Accept  json
// @Produce  json
// @Param limit query int false "Number of top regions to return" default(30)
// @Success 200 {array} entity.RegionRevenue
// @Failure 400 {object} errors.DomainError "Invalid request parameters"
// @Failure 500 {object} errors.ApplicationError "Internal server error"
// @Router /v1/metrics/top-regions [get]
func Handler(db *sql.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                decodedReq, err := DecodeTopRegionsRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: DecodeTopRegionsRequest.Error : %v", logPrefix, err)
                        errors.EncodeError(w, errors.NewDomainError("Invalid request params", 10003))
                        return
                }</span>
                <span class="cov0" title="0">req := decodedReq.(entity.TopRegionsRequest)

                service := services.NewGetTopRegionsService(repository.NewTransactionRepository(db))
                result, err := service.GetTopRegions(ctx, req.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: GetTopRegionsService.GetTopRegions.Error : %v", logPrefix, err)
                        errors.EncodeError(w, errors.NewDomainError("Failed to fetch top regions", 12214))
                        return
                }</span>

                <span class="cov0" title="0">if err := EncodeTopRegionsResponse(ctx, w, result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR [%s]: failed to encode response: %v", logPrefix, err)
                        errors.EncodeError(w, errors.NewApplicationError("Failed to encode response", 1234236))
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ping

import (
        "context"
        "net/http"
)

func DecodePingRequest(_ context.Context, r *http.Request) (interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package ping

import (
        "context"
        "encoding/json"
        "net/http"
)

func EncodePingResponse(_ context.Context, w http.ResponseWriter, response interface{}) error <span class="cov8" title="1">{
        r := response.(string)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        return json.NewEncoder(w).Encode(r)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package ping

import (
        "abt-dashboard-api/pkg/errors"
        "log"
        "net/http"
)

const prefixHttpHandler = "abt-dashboard-api.internal.application.http.ping.handler"

// PingHandler godoc
// @Summary Health Check
// @Description Returns a simple ping response to verify that the server is running.
// @Tags Utility
// @Accept  json
// @Produce  json
// @Success 200 {string} string "ping"
// @Failure 500 {object} errors.ApplicationError
// @Router /ping [get]
func Handler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        response := "ping"
        if err := EncodePingResponse(ctx, w, response); err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [%s]: failed to encode ping response: %v", prefixHttpHandler, err)
                appErr := errors.NewApplicationError("Oops, Something went wrong!", 1234234)
                errors.EncodeError(w, appErr)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package http

import (
        _ "abt-dashboard-api/docs"
        "abt-dashboard-api/internal/application/http/getCountryRevenue"
        "abt-dashboard-api/internal/application/http/getMonthlySalesVolume"
        "abt-dashboard-api/internal/application/http/getTopProducts"
        "abt-dashboard-api/internal/application/http/getTopRegions"
        "abt-dashboard-api/internal/application/http/ping"
        pkgErrors "abt-dashboard-api/pkg/errors"
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"
        "net"
        "net/http"
        "time"

        "github.com/go-chi/cors"

        httpSwagger "github.com/swaggo/http-swagger"

        "github.com/go-chi/chi/v5"
)

type Server struct {
        Server *http.Server
        DbConn *sql.DB
}

func NewServer(abtDashboardDBConn *sql.DB) *Server <span class="cov0" title="0">{
        return &amp;Server{
                DbConn: abtDashboardDBConn,
        }
}</span>

func (s *Server) Start(ctx context.Context) <span class="cov0" title="0">{

        r := s.registerRouter()

        port := 8080
        readTimeout := 5 * time.Second
        writeTimeout := 10 * time.Second
        idleTimeout := 15 * time.Second

        s.Server = &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", port),
                Handler:      r,
                ReadTimeout:  readTimeout,
                WriteTimeout: writeTimeout,
                IdleTimeout:  idleTimeout,
        }

        go func() </span><span class="cov0" title="0">{
                if err := s.Server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("Server started on port %d", port)</span>

}

func (s *Server) Stop(ctx context.Context) <span class="cov0" title="0">{
        err := s.Server.Shutdown(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("transport.server.Stop.error stopping transport server : %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("Server gracefully stopped")</span>
}

func (s *Server) registerRouter() http.Handler <span class="cov0" title="0">{
        r := chi.NewRouter()

        r.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: false,
                MaxAge:           300,
        }))

        r.Use(SimpleContextMiddleware)
        r.Use(LoggingMiddleware)
        r.Use(RecoveryMiddleware)

        r.Get("/ping", ping.Handler)
        r.Get("/v1/metrics/country-revenue", getCountryRevenue.Handler(s.DbConn))
        r.Get("/v1/metrics/top-products", getTopProducts.Handler(s.DbConn))
        r.Get("/v1/metrics/monthly-sales", getMonthlySalesVolume.Handler(s.DbConn))
        r.Get("/v1/metrics/top-regions", getTopRegions.Handler(s.DbConn))

        // Swagger Docs
        r.Get("/swagger/*", httpSwagger.WrapHandler)

        r.NotFound(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                pkgErrors.EncodeError(w, pkgErrors.New("route not found", 404))
        }</span>)

        <span class="cov0" title="0">r.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                pkgErrors.EncodeError(w, pkgErrors.New("method not allowed", 405))
        }</span>)

        <span class="cov0" title="0">return r</span>
}

func SimpleContextMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()
                next.ServeHTTP(w, r.WithContext(ctx))
        }</span>)
}

func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
                next.ServeHTTP(rw, r)
                duration := time.Since(start)
                ip, _, _ := net.SplitHostPort(r.RemoteAddr)
                log.Printf("%s %s %d %s %s", r.Method, r.URL.Path, rw.statusCode, duration, ip)
        }</span>)
}

func RecoveryMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                pkgErrors.EncodeError(w, pkgErrors.New(fmt.Sprintf("internal error: %v", err), 500))
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "abt-dashboard-api/internal/domain/boundary"
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "database/sql"
        "log"
)

const logPrefixTransactionRepository = "abt-dashboard-api.internal.domain.repository.get_country_revenue"

type transactionRepo struct {
        db *sql.DB
}

func NewTransactionRepository(db *sql.DB) boundary.TransactionsRepositoryInterface <span class="cov8" title="1">{
        return &amp;transactionRepo{
                db: db,
        }
}</span>

func (r *transactionRepo) GetCountryRevenue(ctx context.Context, limit int, offset int) (response *[]entity.CountryRevenueResponse, err error) <span class="cov8" title="1">{

        query := `
                SELECT country, product_name, total_revenue, transaction_count
                FROM transaction_summary
                ORDER BY total_revenue DESC
                LIMIT ? OFFSET ?;
        `

        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [%s]: r.db.QueryContext.Error: %v", logPrefixTransactionRepository, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []entity.CountryRevenueResponse
        for rows.Next() </span><span class="cov8" title="1">{
                var row entity.CountryRevenueResponse
                if err := rows.Scan(&amp;row.Country, &amp;row.ProductName, &amp;row.TotalRevenue, &amp;row.TransactionCount); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">results = append(results, row)</span>
        }

        <span class="cov8" title="1">return &amp;results, nil</span>
}

func (r *transactionRepo) GetTopProducts(ctx context.Context, limit int) (response *[]entity.TopProduct, err error) <span class="cov8" title="1">{

        query := `
        SELECT 
    product_id,
    product_name,
    total_purchased,
    stock_quantity
        FROM product_purchase_summary
        ORDER BY total_purchased DESC
                LIMIT ?;
        `

        rows, err := r.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [repository.top_products]: Query error: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []entity.TopProduct
        for rows.Next() </span><span class="cov8" title="1">{
                var row entity.TopProduct
                if err := rows.Scan(&amp;row.ProductId, &amp;row.ProductName, &amp;row.PurchaseCount, &amp;row.AvailableStock); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">results = append(results, row)</span>
        }

        <span class="cov8" title="1">return &amp;results, nil</span>
}

func (r *transactionRepo) RefreshSummaryTables(ctx context.Context) error <span class="cov8" title="1">{
        // Step 1: Refresh transaction_summary
        if _, err := r.db.ExecContext(ctx, `DROP TABLE IF EXISTS transaction_summary`); err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [%s]: Failed to drop transaction_summary: %v", logPrefixTransactionRepository, err)
                return err
        }</span>

        <span class="cov8" title="1">if _, err := r.db.ExecContext(ctx, `
                CREATE TABLE transaction_summary AS
                SELECT
                        country,
                        product_name,
                        SUM(price * quantity) AS total_revenue,
                        COUNT(*) AS transaction_count
                FROM transactions
                GROUP BY country, product_name
        `); err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [%s]: Failed to create transaction_summary: %v", logPrefixTransactionRepository, err)
                return err
        }</span>

        // Step 2: Refresh product_purchase_summary
        <span class="cov8" title="1">if _, err := r.db.ExecContext(ctx, `DROP TABLE IF EXISTS product_purchase_summary`); err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [%s]: Failed to drop product_purchase_summary: %v", logPrefixTransactionRepository, err)
                return err
        }</span>

        <span class="cov8" title="1">if _, err := r.db.ExecContext(ctx, `
                CREATE TABLE product_purchase_summary AS
                SELECT 
                        product_id,
                        product_name,
                        SUM(quantity) AS total_purchased,
                        MAX(stock_quantity) AS stock_quantity
                FROM transactions
                GROUP BY product_id, product_name
        `); err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [%s]: Failed to create product_purchase_summary: %v", logPrefixTransactionRepository, err)
                return err
        }</span>

        <span class="cov8" title="1">log.Printf("INFO [%s]: Summary tables refreshed successfully (via DROP + CREATE)", logPrefixTransactionRepository)
        return nil</span>
}

func (r *transactionRepo) GetMonthlySalesVolume(ctx context.Context, limit int) (*[]entity.MonthlySalesVolume, error) <span class="cov8" title="1">{
        query := `
                SELECT DATE_FORMAT(transaction_date, '%Y-%m') AS month, SUM(quantity) AS total_sales
                FROM transactions
                GROUP BY month
                ORDER BY total_sales DESC
                LIMIT ?;
        `

        rows, err := r.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [%s]: Failed to fetch monthly sales: %v", logPrefixTransactionRepository, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []entity.MonthlySalesVolume
        for rows.Next() </span><span class="cov8" title="1">{
                var row entity.MonthlySalesVolume
                if err := rows.Scan(&amp;row.Month, &amp;row.TotalSales); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">results = append(results, row)</span>
        }

        <span class="cov8" title="1">return &amp;results, nil</span>
}

func (r *transactionRepo) GetTopRegions(ctx context.Context, limit int) (*[]entity.RegionRevenue, error) <span class="cov8" title="1">{
        query := `
        SELECT 
                region,
                SUM(price * quantity) AS total_revenue,
                SUM(quantity) AS items_sold
        FROM transactions
        GROUP BY region
        ORDER BY total_revenue DESC
        LIMIT ?;
        `

        rows, err := r.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR [repository.top_regions]: Query error: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []entity.RegionRevenue
        for rows.Next() </span><span class="cov8" title="1">{
                var row entity.RegionRevenue
                if err := rows.Scan(&amp;row.Region, &amp;row.TotalRevenue, &amp;row.ItemsSold); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">results = append(results, row)</span>
        }
        <span class="cov8" title="1">return &amp;results, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "abt-dashboard-api/internal/domain/boundary"
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "log"
)

const prefixGetCountryRevenue = `abt-dashboard-api.internal.domain.services.get_country_revenue`

type getCountryRevenueService struct {
        transactionsRepository boundary.TransactionsRepositoryInterface
}

func NewGetCountryRevenueService(transactionsRepository boundary.TransactionsRepositoryInterface) boundary.GetCountryRevenueService <span class="cov8" title="1">{
        return &amp;getCountryRevenueService{
                transactionsRepository: transactionsRepository,
        }
}</span>

func (g *getCountryRevenueService) GetCountryRevenue(ctx context.Context, limit int, offset int) (countryRevenueDetails *[]entity.CountryRevenueResponse, err error) <span class="cov8" title="1">{

        countryRevenueDetails, err = g.transactionsRepository.GetCountryRevenue(ctx, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [%s]: g.transactionsRepository.GetCountryRevenue.Error: %v", prefixGetCountryRevenue, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return countryRevenueDetails, nil</span>

}
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "abt-dashboard-api/internal/domain/boundary"
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "log"
)

type getTopRegionsService struct {
        repo boundary.TransactionsRepositoryInterface
}

func NewGetTopRegionsService(repo boundary.TransactionsRepositoryInterface) boundary.GetTopRegionsService <span class="cov8" title="1">{
        return &amp;getTopRegionsService{repo: repo}
}</span>

func (s *getTopRegionsService) GetTopRegions(ctx context.Context, limit int) (topRegions *[]entity.RegionRevenue, err error) <span class="cov8" title="1">{
        topRegions, err = s.repo.GetTopRegions(ctx, limit)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [services.get_top_regions]: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return topRegions, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "abt-dashboard-api/internal/domain/boundary"
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "log"
)

type monthlySalesService struct {
        transactionsRepository boundary.TransactionsRepositoryInterface
}

func NewMonthlySalesService(transactionsRepository boundary.TransactionsRepositoryInterface) boundary.MonthlySalesService <span class="cov8" title="1">{
        return &amp;monthlySalesService{transactionsRepository: transactionsRepository}
}</span>

func (s *monthlySalesService) GetMonthlySalesVolume(ctx context.Context, limit int) (monthlySalesVolumes *[]entity.MonthlySalesVolume, err error) <span class="cov8" title="1">{
        monthlySalesVolumes, err = s.transactionsRepository.GetMonthlySalesVolume(ctx, limit)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [services.monthly_sales]: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return monthlySalesVolumes, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "abt-dashboard-api/internal/domain/boundary"
        "abt-dashboard-api/internal/domain/entity"
        "context"
        "log"
)

type getTopProductsService struct {
        topProductsRepo boundary.TransactionsRepositoryInterface
}

func NewGetTopProductsService(repo boundary.TransactionsRepositoryInterface) boundary.GetTopProductsService <span class="cov8" title="1">{
        return &amp;getTopProductsService{topProductsRepo: repo}
}</span>

func (s *getTopProductsService) GetTopProducts(ctx context.Context, limit int) (products *[]entity.TopProduct, err error) <span class="cov8" title="1">{
        products, err = s.topProductsRepo.GetTopProducts(ctx, limit)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("ERROR [services.get_top_products]: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return products, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package internal

import (
        "abt-dashboard-api/internal/application/cron"
        "abt-dashboard-api/internal/application/database"
        "abt-dashboard-api/internal/application/http"
        pkgDB "abt-dashboard-api/pkg/database"

        "context"
        "database/sql"
        "log"
        "os"
        "os/signal"
        "syscall"
)

// Init @title ABT Dashboard API
// @version 1.0
// @description This is the backend API documentation for ABT Corporations dashboard.
// @host localhost:8080
// @BasePath /
func Init() <span class="cov0" title="0">{

        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        os.Setenv("DB_NAME", "abt_dashboard")
        os.Setenv("DB_USERNAME", "root")
        os.Setenv("DB_PASSWORD", "123")

        dbName := os.Getenv("DB_NAME")
        if dbName == "" </span><span class="cov0" title="0">{
                panic("DB_NAME environment variable not set")</span>
        }

        <span class="cov0" title="0">dbUserName := os.Getenv("DB_USERNAME")
        if dbUserName == "" </span><span class="cov0" title="0">{
                panic("DB_USERNAME environment variable not set")</span>
        }

        <span class="cov0" title="0">dbPassword := os.Getenv("DB_PASSWORD")
        if dbPassword == "" </span><span class="cov0" title="0">{
                panic("DB_PASSWORD environment variable not set")</span>
        }

        <span class="cov0" title="0">abtDashboardDBConn, err := database.NewDbConfig(
                dbUserName,
                dbPassword,
                dbName,
                "127.0.0.1",
                "3306",
                "300s",
                "300s",
                "30s",
        ).NewDatabaseConnection(pkgDB.DefaultConnector{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">defer func(abtDashboardDatabase *sql.DB) </span><span class="cov0" title="0">{
                err := abtDashboardDatabase.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error occurred while closing Database connection pool  : %v", err)
                }</span>
        }(abtDashboardDBConn)

        <span class="cov0" title="0">cronJob := cron.StartSummaryTableRefreshJob(abtDashboardDBConn)
        defer cronJob.Stop()

        httpServer := http.NewServer(abtDashboardDBConn)
        httpServer.Start(ctx)

        select </span>{
        case &lt;-sigs:<span class="cov0" title="0">
                httpServer.Stop(ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "abt-dashboard-api/internal"
        _ "net/http/pprof"
)

func main() <span class="cov0" title="0">{

        internal.Init()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package database

import "database/sql"

type SQLConnector interface {
        Open(driverName, dsn string) (*sql.DB, error)
        Ping(db *sql.DB) error
}

type DefaultConnector struct{}

func (DefaultConnector) Open(driverName, dsn string) (*sql.DB, error) <span class="cov0" title="0">{
        return sql.Open(driverName, dsn)
}</span>

func (DefaultConnector) Ping(db *sql.DB) error <span class="cov0" title="0">{
        return db.Ping()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package errors

import (
        "encoding/json"
        "fmt"
        "net/http"
)

type ApplicationError struct {
        Message string `json:"message"`
        Code    int    `json:"code"`
}

func (e ApplicationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Application Error: %s (%d)", e.Message, e.Code)
}</span>

func NewApplicationError(message string, code int) ApplicationError <span class="cov8" title="1">{
        return ApplicationError{
                Message: message,
                Code:    code,
        }
}</span>

type DomainError struct {
        Message string `json:"message"`
        Code    int    `json:"code"`
}

func (e DomainError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Domain Error: %s (%d)", e.Message, e.Code)
}</span>

func NewDomainError(message string, code int) DomainError <span class="cov8" title="1">{
        return DomainError{
                Message: message,
                Code:    code,
        }
}</span>

type GeneralError struct {
        Message string `json:"message"`
        Code    int    `json:"code"`
}

func (e GeneralError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("General Error: %s (%d)", e.Message, e.Code)
}</span>

func New(message string, code int) error <span class="cov8" title="1">{
        return GeneralError{
                Message: message,
                Code:    code,
        }
}</span>

type ValidationError struct {
        Message   string   `json:"message"`
        Code      int      `json:"code"`
        FieldErrs []string `json:"fieldErrors"`
}

func (e ValidationError) Error() string <span class="cov8" title="1">{
        return "Validation Error"
}</span>

func NewValidationError(message string, fieldErrs []error, code int) ValidationError <span class="cov8" title="1">{
        errStrings := make([]string, 0, len(fieldErrs))
        for _, err := range fieldErrs </span><span class="cov8" title="1">{
                errStrings = append(errStrings, err.Error())
        }</span>
        <span class="cov8" title="1">return ValidationError{
                Message:   message,
                Code:      code,
                FieldErrs: errStrings,
        }</span>
}

func IsDomain(err error) bool <span class="cov8" title="1">{
        _, ok := err.(DomainError)
        return ok
}</span>

func IsApplication(err error) bool <span class="cov8" title="1">{
        _, ok := err.(ApplicationError)
        return ok
}</span>

func IsValidation(err error) bool <span class="cov8" title="1">{
        _, ok := err.(ValidationError)
        return ok
}</span>

func IsGeneral(err error) bool <span class="cov8" title="1">{
        _, ok := err.(GeneralError)
        return ok
}</span>

func EncodeError(w http.ResponseWriter, err error) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        switch e := err.(type) </span>{
        case ValidationError:<span class="cov8" title="1">
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(e)</span>
        case DomainError:<span class="cov8" title="1">
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(e)</span>
        case ApplicationError:<span class="cov8" title="1">
                w.WriteHeader(http.StatusInternalServerError)
                _ = json.NewEncoder(w).Encode(e)</span>
        case GeneralError:<span class="cov8" title="1">
                w.WriteHeader(http.StatusInternalServerError)
                _ = json.NewEncoder(w).Encode(e)</span>
        default:<span class="cov8" title="1">
                w.WriteHeader(http.StatusInternalServerError)
                _ = json.NewEncoder(w).Encode(map[string]string{
                        "message": "internal server error",
                        "code":    "500",
                })</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
